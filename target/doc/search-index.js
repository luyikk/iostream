var N = null;var searchIndex = {};
searchIndex["iostream"]={"doc":"","items":[[0,"io","iostream","",N,N],[4,"SeekOrigin","iostream::io","",N,N],[13,"Begin","","Specifies the beginning of a stream.",0,N],[13,"Current","","Specifies the current position within a stream.",0,N],[13,"End","","Specifies the end of a stream.",0,N],[0,"memory","","",N,N],[0,"memory_stream","iostream::io::memory","",N,N],[3,"MemoryStream","iostream::io::memory::memory_stream","",N,N],[11,"new","","",1,[[],["memorystream"]]],[11,"new_to","","",1,N],[11,"to_vec","","return current stream data to Vec",1,[[["self"]],["vec",["u8"]]]],[11,"clear","","Clears the vector, removing all values,and set position =0",1,[[["self"]]]],[11,"set_position","","",1,[[["self"],["u64"]],["result",["string"]]]],[11,"position","","",1,[[["self"]],["u64"]]],[11,"length","","",1,[[["self"]],["u64"]]],[11,"set_length","","",1,[[["self"],["u64"]],["result",["string"]]]],[11,"can_write","","",1,[[["self"]],["bool"]]],[11,"can_read","","",1,[[["self"]],["bool"]]],[11,"can_seek","","",1,[[["self"]],["bool"]]],[11,"read_all","","",1,[[["self"],["vec"]],["result",["usize","string"]]]],[11,"read","","",1,N],[11,"read_byte","","",1,[[["self"]],["result",["u8","string"]]]],[11,"seek","","",1,[[["self"],["i64"],["seekorigin"]],["result",["u64","string"]]]],[11,"write_all","","",1,N],[11,"write","","`rust use iostream::io::*; let mut ms= MemoryStream::new(); let data2:[u8;100]=[2;100]; ms.write(&data2,50,50).unwrap();`",1,N],[11,"flush","","",1,[[["self"]],["result",["string"]]]],[0,"file","iostream::io","",N,N],[3,"FileStream","iostream::io::file","the file stream from disk file,you can use it, wr file",N,N],[12,"file","","",2,N],[4,"FileMode","","",N,N],[13,"CreateNew","","Specifies that the operating system should create a new file. This requires System.Security.Permissions.FileIOPermissionAccess.Write permission. If the file already exists, an System.IO.IOException exception is thrown.",3,N],[13,"Create","","Specifies that the operating system should create a new file. If the file already exists, it will be overwritten. This requires System.Security.Permissions.FileIOPermissionAccess.Write permission. FileMode.Create is equivalent to requesting that if the file does not exist, use System.IO.FileMode.CreateNew; otherwise, use System.IO.FileMode.Truncate. If the file already exists but is a hidden file, an System.UnauthorizedAccessException exception is thrown.",3,N],[13,"Open","","Specifies that the operating system should open an existing file. The ability to open the file is dependent on the value specified by the System.IO.FileAccess enumeration. A System.IO.FileNotFoundException exception is thrown if the file does not exist.",3,N],[13,"OpenOrCreate","","Specifies that the operating system should open a file if it exists; otherwise, a new file should be created. If the file is opened with FileAccess.Read, System.Security.Permissions.FileIOPermissionAccess.Read permission is required. If the file access is FileAccess.Write, System.Security.Permissions.FileIOPermissionAccess.Write permission is required. If the file is opened with FileAccess.ReadWrite, both System.Security.Permissions.FileIOPermissionAccess.Read and System.Security.Permissions.FileIOPermissionAccess.Write permissions are required.",3,N],[13,"Truncate","","Specifies that the operating system should open an existing file. When the file is opened, it should be truncated so that its size is zero bytes. This requires System.Security.Permissions.FileIOPermissionAccess.Write permission. Attempts to read from a file opened with FileMode.Truncate cause an System.ArgumentException exception.",3,N],[13,"Append","","Opens the file if it exists and seeks to the end of the file, or creates a new file. This requires System.Security.Permissions.FileIOPermissionAccess.Append permission. FileMode.Append can be used only in conjunction with FileAccess.Write. Trying to seek to a position before the end of the file throws an System.IO.IOException exception, and any attempt to read fails and throws a System.NotSupportedException exception.",3,N],[4,"FileAccess","","Defines constants for read, write, or read/write access to a file.",N,N],[13,"Read","","Read access to the file. Data can be read from the file. Combine with Write for read/write access.",4,N],[13,"Write","","Write access to the file. Data can be written to the file. Combine with Read for read/write access.",4,N],[13,"ReadWrite","","Read and write access to the file. Data can be written to and read from the file.",4,N],[8,"FsOption","","from std::fs::File open file stream",N,N],[10,"open_fs","","",5,[[["str"],["filemode"],["fileaccess"]],["result",["filestream","string"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","create filestream, path is file path, mode is open mode, access is wr mode `rus let mut fs=File::open_fs(\"c.data\",FileMode::CreateNew,FileAccess::ReadWrite).unwrap();`",2,[[["str"],["filemode"],["fileaccess"]],["result",["filestream","string"]]]],[11,"set_position","","",2,[[["self"],["u64"]],["result",["string"]]]],[11,"position","","",2,[[["self"]],["u64"]]],[11,"length","","",2,[[["self"]],["u64"]]],[11,"set_length","","",2,[[["self"],["u64"]],["result",["string"]]]],[11,"can_write","","",2,[[["self"]],["bool"]]],[11,"can_read","","",2,[[["self"]],["bool"]]],[11,"can_seek","","",2,[[["self"]],["bool"]]],[11,"read_all","","",2,[[["self"],["vec"]],["result",["usize","string"]]]],[11,"read","","",2,N],[11,"read_byte","","",2,[[["self"]],["result",["u8","string"]]]],[11,"seek","","",2,[[["self"],["i64"],["seekorigin"]],["result",["u64","string"]]]],[11,"write_all","","",2,N],[11,"write","","",2,N],[11,"flush","","",2,[[["self"]],["result",["string"]]]],[0,"stream_rw","iostream::io","",N,N],[4,"EndianType","iostream::io::stream_rw","",N,N],[13,"LittleEndian","","",6,N],[13,"BigEndian","","",6,N],[0,"stream_reader","","",N,N],[3,"StreamReader","iostream::io::stream_rw::stream_reader","reader stream struct",N,N],[12,"base_stream","","",7,N],[11,"from","","from stream use LittleEndian reader integer `rust use iostream::io::*; let mut ms=MemoryStream::new(); //...write data to ms let mut ws: StreamReader = StreamReader::from(&mut ms).unwrap();`",7,[[["stream"]],["result",["streamreader","string"]]]],[11,"from_big_endian","","from stream use BigEndian reader integer `rust use iostream::io::*; let mut ms=MemoryStream::new(); //...write data to ms let mut ws: StreamReader = StreamReader::from_big_endian(&mut ms).unwrap();`",7,[[["stream"]],["result",["streamreader","string"]]]],[11,"read_byte","","read u8 from stream",7,[[["self"]],["result",["u8","string"]]]],[11,"read_all","","read vec from stream,return read length",7,[[["self"],["vec"]],["result",["usize","string"]]]],[11,"read","","read [u8] from stream,can use offset and count buff position,return read len",7,N],[11,"read_i16","","read i16 from stream,return it value",7,[[["self"]],["result",["i16","string"]]]],[11,"read_u16","","read u16 from stream,return it value",7,[[["self"]],["result",["u16","string"]]]],[11,"read_u32","","read u32 from stream,return it value",7,[[["self"]],["result",["u32","string"]]]],[11,"read_i32","","read i32 from stream,return it value",7,[[["self"]],["result",["i32","string"]]]],[11,"read_i64","","read i64 from stream,return it value",7,[[["self"]],["result",["i64","string"]]]],[11,"read_u64","","read u64 from stream,return it value",7,[[["self"]],["result",["u64","string"]]]],[11,"read_u8_array","","read vec from the current stream,can specify need read length to buffer ```rust     use iostream::io::*;     let mut ms=MemoryStream::new();     let data:[u8;1024]=[5;1024];     ms.write_all(&data).unwrap();",7,[[["self"],["i32"]],["result",["vec","string"]]]],[0,"stream_writer","iostream::io::stream_rw","",N,N],[3,"StreamWriter","iostream::io::stream_rw::stream_writer","write stream struct",N,N],[12,"base_stream","","",8,N],[11,"from","","from stream use LittleEndian write integer `rust use iostream::io::*; let mut ms=MemoryStream::new(); //...write data to ms let mut ws: StreamWriter = StreamWriter::from(&mut ms).unwrap();`",8,[[["stream"]],["result",["streamwriter","string"]]]],[11,"from_big_endian","","from stream use BigEndian write integer `rust use iostream::io::*; let mut ms=MemoryStream::new(); //...write data to ms let mut ws: StreamReader = StreamReader::from_big_endian(&mut ms).unwrap();`",8,[[["stream"]],["result",["streamwriter","string"]]]],[11,"write","","read [u8] from stream,can use offset and count buff position,return read len",8,N],[11,"write_all","","read vec from stream,return read length",8,N],[11,"write_byte","","write u8 from stream",8,[[["self"],["u8"]],["result",["string"]]]],[11,"write_i16","","write i16 from stream,return it value",8,[[["self"],["i16"]],["result",["string"]]]],[11,"write_u16","","write u16 from stream,return it value",8,[[["self"],["u16"]],["result",["string"]]]],[11,"write_i32","","write i32 from stream,return it value",8,[[["self"],["i32"]],["result",["string"]]]],[11,"write_u32","","write u32 from stream,return it value",8,[[["self"],["u32"]],["result",["string"]]]],[11,"write_i64","","write i64 from stream,return it value",8,[[["self"],["i64"]],["result",["string"]]]],[11,"write_u64","","write u64 from stream,return it value",8,[[["self"],["u64"]],["result",["string"]]]],[8,"Stream","iostream::io","",N,N],[11,"copy_to","","copy current stream to target stream ```rust   use iostream::io::*;   use std::fs::File;",9,[[["self"],["stream"]],["result",["string"]]]],[10,"set_position","","gets or sets the position within the current stream",9,[[["self"],["u64"]],["result",["string"]]]],[10,"position","","The current position within the stream.",9,[[["self"]],["u64"]]],[10,"length","","A long value representing the length of the stream in bytes.",9,[[["self"]],["u64"]]],[10,"set_length","","Sets the length of this stream to the given value.",9,[[["self"],["u64"]],["result",["string"]]]],[10,"can_write","","gets a value indicating whether the current stream supports writing. true if the stream supports writing; otherwise, false.",9,[[["self"]],["bool"]]],[10,"can_read","","gets a value indicating whether the current  stream supports reading. true if the stream supports reading; otherwise, false.",9,[[["self"]],["bool"]]],[10,"can_seek","","gets a value indicating whether the current  stream supports seeking.",9,[[["self"]],["bool"]]],[10,"read_all","","When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.",9,[[["self"],["vec"]],["result",["usize","string"]]]],[10,"read","","reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.",9,N],[10,"read_byte","","Reads a byte from the stream and advances the position within the stream by one byte, or Err returns -1 if at the end of the stream.",9,[[["self"]],["result",["u8","string"]]]],[10,"seek","","sets the position within the current stream.",9,[[["self"],["i64"],["seekorigin"]],["result",["u64","string"]]]],[10,"write_all","","writes a sequence of all bytes to the current stream",9,N],[10,"write","","writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.",9,N],[10,"flush","","clears all buffers for this stream and causes any buffered data to be written to the underlying device.",9,[[["self"]],["result",["string"]]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","iostream::io::memory::memory_stream","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","iostream::io::file","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","iostream::io::stream_rw","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","iostream::io::stream_rw::stream_reader","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","iostream::io::stream_rw::stream_writer","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]]],"paths":[[4,"SeekOrigin"],[3,"MemoryStream"],[3,"FileStream"],[4,"FileMode"],[4,"FileAccess"],[8,"FsOption"],[4,"EndianType"],[3,"StreamReader"],[3,"StreamWriter"],[8,"Stream"]]};
initSearch(searchIndex);
